# JAGS model for delay discounting.
# - model of multiple participants
# - models the magnitude effect
# - separate parameters (for each participant) for lapse rate and alpha
# - Heirachical estimation (group-level) estimates of magnitude effect parameters (m, c).

model{

    # Group-level hyperpriors  ------------------------

#    # slope (informative, see Appendix A)
#    glM             ~ dnorm(groupMmu, 1/(groupMsigma^2))
#    groupMmu        ~ dnorm(-0.243, 1/(0.027^2))
#    groupMsigma     ~ dnorm( 0.072, 1/(0.025^2)) T(0,)
#
#    # slope (sample from the prior, independent from the data)
#    glMprior        ~ dnorm(groupMmuprior, 1/(groupMsigmaprior^2))
#    groupMmuprior   ~ dnorm(-0.243, 1/(0.027^2))
#    groupMsigmaprior~ dnorm( 0.072, 1/(0.025^2)) T(0,)



    # DOUBLE THE STANDARD DEVIATION FROM THE EMPIRICAL ESTIMATES
    # slope (uninformative, see Appendix A)
    glM             ~ dnorm(groupMmu, 1/(groupMsigma^2))
    groupMmu        ~ dnorm(-0.243, 1/( (0.027*10)^2))
    groupMsigma     ~ dnorm( 0.072, 1/( (0.025*10)^2)) T(0,)

    # slope (sample from the prior, independent from the data)
    glMprior        ~ dnorm(groupMmuprior, 1/(groupMsigmaprior^2))
    groupMmuprior   ~ dnorm(-0.243, 1/( (0.027*10)^2))
    groupMsigmaprior~ dnorm( 0.072, 1/( (0.025*10)^2)) T(0,)



    # intercept (see Appendix A)
    glC             ~ dnorm(groupCmu, 1/(groupCsigma^2))
    groupCmu        ~ dnorm(0, 1/(10000^2))
    groupCsigma     ~ dunif(0, 10000) 

    # intercept (sample from the prior, independent from the data)
    glCprior             ~ dnorm(groupCmuprior, 1/(groupCsigmaprior^2))
    groupCmuprior        ~ dnorm(0, 1/(10000^2))
    groupCsigmaprior     ~ dunif(0, 10000) 



    # comparison acuity (alpha)
    glALPHA             ~ dnorm(groupALPHAmu, 1/(groupALPHAsigma^2)) T(0,)
    groupALPHAmu        ~ dunif(0,10000)
    groupALPHAsigma     ~ dunif(0,10000)
    
    # comparison acuity (sample from the prior, independent from the data)
    glALPHAprior         ~ dnorm(groupALPHAmuprior, 1/(groupALPHAsigmaprior^2)) T(0,)
    groupALPHAmuprior    ~ dunif(0,10000)
    groupALPHAsigmaprior ~ dunif(0,10000)



    # error rates (epsilon)
    glEpsilon       ~ dbeta(groupW*(groupK-2)+1 , (1-groupW)*(groupK-2)+1 ) T(,0.5)
    groupW          ~ dbeta(1.1, 10.9)  # mode for lapse rate
    groupKminus2    ~ dgamma(0.01,0.01) # concentration parameter
    groupK          <- groupKminus2+2

    # error rates (prior, independent from the data)
    glEpsilonprior      ~ dbeta(groupWprior*(groupKprior-2)+1 , (1-groupWprior)*(groupKprior-2)+1 ) T(,0.5)
    groupWprior          ~ dbeta(1.1, 10.9)  # mode for lapse rate
    groupKminus2prior    ~ dgamma(0.01,0.01) # concentration parameter
    groupKprior          <- groupKminus2prior+2

       


    # Participant-level ------------------------------
    # HIERACHICAL i.e. parameter estimates for each person. Each variable is drawn from a group-level distribution.
    for (p in 1:nParticipants){
        # magnitide effect (m,c) for each person
        m[p]        ~ dnorm(groupMmu, 1/(groupMsigma^2))
        c[p]        ~ dnorm(groupCmu, 1/(groupCsigma^2))
        epsilon[p]  ~ dbeta(groupW*(groupK-2)+1 , (1-groupW)*(groupK-2)+1 ) T(,0.5)
        alpha[p]    ~ dnorm(groupALPHAmu, 1/(groupALPHAsigma^2)) T(0,)
    }

    # samples from participant level priors (which are the same for all participants)
    # this is not essential, but it is useful to have these prior distributions
    #epsilonprior    ~ dbeta( groupW*(groupK-2)+1 , (1-groupW)*(groupK-2)+1)
    #alphaprior      ~ dnorm(groupALPHAmu, 1/groupALPHAsigma) T(0,)
    #mprior          ~ dnorm(groupMmu, 1/(groupMsigma^2))
    #cprior          ~ dnorm(groupCmu, 1/(groupCsigma^2))

    for (p in 1:nParticipants){
        for (t in 1:T[p]) {  

            # Calculate log discount rate for each reward
            lkA[p,t] <- m[p]*log(A[p,t])+c[p]
            lkB[p,t] <- m[p]*log(B[p,t])+c[p]

            # calculate present subjective value for each reward
            VA[p,t] <- A[p,t] / (1+(exp(lkA[p,t])*DA[p,t]))
            VB[p,t] <- B[p,t] / (1+(exp(lkB[p,t])*DB[p,t]))

            # psychometric function
            P[p,t] <- epsilon[p] + (1-2*epsilon[p]) * phi( (VB[p,t]-VA[p,t]) / alpha[p] )

            # response
            R[p,t] ~ dbin(P[p,t],1)
        }
    }
}
